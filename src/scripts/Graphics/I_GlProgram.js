"use strict";
import { Camera } from '../Engine/Renderer/Camera.js'
import { GetShaderTypeId } from './Debug/GfxDebug.js';
import * as GlOps from './GlBufferOps.js';


export class GfxInfoMesh {

	sceneIdx = INT_NULL;
	sid = INT_NULL;
	numFaces = 0;
	vertsPerRect = 0;
	attribsPerVertex = 0;
	meshIdx = INT_NULL; // The index of the current mesh in the vertexBuffer's array of meshes

	prog = {
		idx: INT_NULL,
	}
	vao = null;

	vb = { // The vertex buffer info the mesh belongs to

		buffer: null,
		idx: INT_NULL,			// The vertex buffer (float*) idx that this Mesh is stored to.
		start: 0,		// The current meshe's starting idx in vertex buffer. 
		count: 0,		// Current size of the float buffer (in floats)
	};

	ib = { // The vertex buffer info the mesh belongs to

		buffer: null,
		idx: INT_NULL,			// The idx buffer's  idx.
		start: 0,		// The current meshe's starting idx in vertex buffer. 
		count: 0,		// Number of total meshe's attributes  
	};

	tb = { // The Texture info for the mesh

		id: INT_NULL,     // An id generated by webGl (texture unit: GL_TEXTURE0)
		idx: INT_NULL,
	};

	// constructor(vao,numFaces,vertsPerRect,attribsPerVertex,
	// 				progIdx,vbIdx,glBuffer,start,count,sceneIdx,sid){
	// 	this.vao              = vao;
	// 	this.numFaces         = numFaces;
	// 	this.vertsPerRect     = vertsPerRect;
	// 	this.attribsPerVertex = attribsPerVertex;
	// 	this.prog.idx         = progIdx;
	// 	this.vb.idx           = vbIdx;
	// 	this.vb.buffer        = glBuffer;
	// 	this.vb.start         = start;
	// 	this.vb.count         = count;
	// 	this.sceneIdx         = sceneIdx;
	// 	this.sid              = sid;
	// }
}

export class VertexBuffer {

	sceneIdx = INT_NULL;

	buffer = null;
	data = [];
	meshes = []; // An array of pointers to all vertexBuffer's meshes. Has the type of 'GfxInfoMesh'

	idx = INT_NULL;	// The vertex buffer (float*) idx that this Mesh is stored to.
	count = 0;			// Current size of the float buffer (in floats)
	size = 0;			// Total   size of the float buffer (in floats)
	start = 0;			// The current meshe's starting idx in the vertex buffer. 
	vCount = 0;			// Nuuumber of vertices

	vao = null;				// Vertex Array 
	vboId = INT_NULL;	// Vertex Buffer Gl-Id
	iboId = INT_NULL;	// Index Buffer Gl-Id
	tboId = INT_NULL;	// Texture Buffer Gl-Id
	texIdx = INT_NULL;	// Stores the index of the texture's location in the texture array


	scissorBox = [];

	show = true;
	needsUpdate = false;
	hasChanged = false;
	hasScissorBox = false;
	
	// Debug
	debug = { meshesNames: [], sidName: '' };
	
	constructor(sid, sceneIdx, idx){
		this.debug.sidName = GetShaderTypeId(sid); 
		this.sceneIdx = sceneIdx; 
		this.idx = idx;
	}
	
	AddMesh(sid, mesh, shaderInfo, numFaces) {
		const start = this.count; // Add meshes to the vb continuously
		const count = numFaces * shaderInfo.verticesPerRect * shaderInfo.attribsPerVertex; // Total attributes to add
		if (sid & SID.ATTR.COL4) { // Add Color, if the program has such an attribute
			GlOps.VbSetAttribCol(this, start + shaderInfo.colOffset,
				count, shaderInfo.attribsPerVertex - V_COL_COUNT, mesh.col);
		}
		if (sid & SID.ATTR.POS2) { // Add Position, if the program has such an attribute 
			GlOps.VbSetAttribPos(this, start + shaderInfo.posOffset,
				count, shaderInfo.attribsPerVertex - V_POS_COUNT, mesh.dim);
		}
		// if (sid & SID.ATTR.SCALE2) { // Add Scale, if the program has such an attribute 
		// 	GlOps.VbSetAttribScale(this, start + shaderInfo.scaleOffset,
		// 		count, shaderInfo.attribsPerVertex - V_SCALE_COUNT, mesh.scale);
		// }
		if (sid & SID.ATTR.TEX2) { // Add Texture, if the program has such an attribute 
			GlOps.VbSetAttribTex(this, start + shaderInfo.texOffset,
				count, shaderInfo.attribsPerVertex - V_TEX_COUNT, mesh.tex);
		}
		if (sid & SID.ATTR.WPOS_TIME4) { // Add World Position, if the program has such an attribute 
			GlOps.VbSetAttribWpos(this, start +shaderInfo.wposTimeOffset,
				count, shaderInfo.attribsPerVertex - V_WPOS_COUNT, mesh.pos);
		}
		if (sid & SID.ATTR.PARAMS1) { // Add World Position, if the program has such an attribute 
			GlOps.VbSetAttribParams1(this, start + shaderInfo.params1Offset,
				count, shaderInfo.attribsPerVertex - V_PARAMS1_COUNT, mesh.attrParams1);
		}
		if (sid & SID.ATTR.SDF_PARAMS) { // The parameters for the rendering of SDF text
			GlOps.VbSetAttrSdfParams(this, start + shaderInfo.sdfParamsOffset,
				count, shaderInfo.attribsPerVertex - V_SDF_PARAMS_COUNT, mesh.sdfParams)
		}
		if (sid & SID.ATTR.STYLE) { // Mesh round corners
			GlOps.VbSetAttrStyle(this, start + shaderInfo.styleOffset,
				count, shaderInfo.attribsPerVertex - V_STYLE_COUNT, mesh.style)
		}
		if (sid & SID.ATTR.TIME) { // Per Vertex Timer (meant to be per mesh, 4 vertices) 
			GlOps.VbSetAttrTime(this, start + shaderInfo.timeOffset,
				count, shaderInfo.attribsPerVertex - V_TIME_COUNT, mesh.time);
		}

		this.needsUpdate = true;
	}
	// Create(){
	// 	vbIdx = progs[progIdx].vertexBufferCount++; 
	// 	progs[progIdx].vertexBuffer[vbIdx] = new VertexBuffer;  
	// 	vb = progs[progIdx].vertexBuffer[vbIdx];  
	// 	vb.debug.sidName = dbg.GetShaderTypeId(sid); 
	// 	vb.sceneIdx = sceneIdx; 
	// 	vb.idx = vbIdx;
		
	// 	const vao = gfxCtx.gl.createVertexArray();
	// 	gfxCtx.gl.bindVertexArray(vao);
	// 	vb.buffer = gfxCtx.gl.createBuffer();
	// 	gfxCtx.gl.bindBuffer(gfxCtx.gl.ARRAY_BUFFER, vb.buffer);
	// 	vb.size = MAX_VERTEX_BUFFER_COUNT;
	// 	vb.data = new Float32Array(vb.size);
	// 	vb.needsUpdate = true;
	// 	vb.vao = vao;
	// }
};

export class IndexBuffer {

	name = '';

	data = [];
	buffer = null;

	idx = INT_NULL;
	start = 0;
	count = 0;
	size = 0;
	vCount = 0;

	vao = null;
	iboId = INT_NULL;

	needsUpdate = false;
};

export class GlProgram extends Camera {

	program = null;
	isActive = false;

	uniformsNeedUpdate = false;

	info = {
		sid: 0,				// Shader Type ID (E.g. ATTR_COL4 | ATTR_POS2 | INDEXED)
		programId: 0,
		progIdx: INT_NULL,
	};
	shaderInfo = {
		colOffset: INT_NULL,
		posOffset: INT_NULL,
		scaleOffset: INT_NULL,
		texOffset: INT_NULL,
		wposTimeOffset: INT_NULL,
		styleOffset: INT_NULL,   // Radius for rounding corners
		timeOffset: INT_NULL,	// Border feather distance	
		sdfParamsOffset: INT_NULL,	// The inner and outer variables to render sdf text
		params1Offset: INT_NULL,	// The inner and outer variables to render sdf text

		attributes: {
			colLoc: INT_NULL,
			posLoc: INT_NULL,
			scaleLoc: INT_NULL,
			texLoc: INT_NULL,
			wposTimeLoc: INT_NULL,
			// wposLoc: INT_NULL,
			styleLoc: INT_NULL,
			timeLoc: INT_NULL,
			sdfParamsLoc: INT_NULL,
			params1Loc: INT_NULL,
		},

		uniforms: {
			orthoProj: null,
			sampler: null,
			paramsBuffer: null,    // Uniform Buffer
			paramsBufferLoc: null,    // Uniform Location
			positionsBuffer: null,    // Uniform Buffer
			positionsBufferLoc: null,    // Uniform Location
			paramsBufferCount: 0,         // Counts the numbber of uniform values
		},

		attribsPerVertex: 0,
		verticesPerRect: 0,
	};
	timer = {
		t: 0., // A uniform variable to time counter
		step: 0.,
		index: INT_NULL,
		isOn: false,
	};

	vertexBuffer = [];
	vertexBufferCount = 0;

	indexBuffer = [];
	indexBufferCount = 0;

	SetTimer(step, uniformBufferIndex) {
		this.timer.isOn = true;
		this.timer.step = step;
		this.timer.index = uniformBufferIndex;
	}
	UpdateTimer() {
		this.shaderInfo.uniforms.paramsBuffer[this.timer.index] = this.timer.t;
		this.uniformsNeedUpdate = true;
		// Increment program's uniform variable timer
		this.timer.t += this.timer.step;
	}


	/**
	 * Uniform buffer for miscellaneous-orbitary number of uniforms for a specific gl program 
	 */
	UniformsSetParamsBufferValue(value, index) {
		this.shaderInfo.uniforms.paramsBuffer[index] = value;
		this.uniformsNeedUpdate = true;
	}

	UniformsUpdateParamsBuffer(glContext) {
		glContext.uniform1fv(this.shaderInfo.uniforms.paramsBufferLoc, this.shaderInfo.uniforms.paramsBuffer); // And the shader decides the number of elements to draw from the buffer
		this.uniformsNeedUpdate = false;

	}

};






export let GlFrameBuffer = {

	name: '',

	buffer: null,
	tex: null,
	texId: INT_NULL,
	texIdx: INT_NULL,
	texWidth: 0,
	texHeight: 0,
	progIdx: INT_NULL,
	vbIdx: INT_NULL,
	isActive: false,
};

let GlUID = INT_NULL; // A unique id for every vertex buffer, to distinguish which meshes belong to which buffer 
export function GlCreateUniqueBufferid() {
	GlUID++;
	return GlUID;
}