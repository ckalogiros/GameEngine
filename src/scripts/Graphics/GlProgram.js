"use strict";
import { Camera } from '../Engine/Renderer/Camera.js'
import { GetShaderTypeId, PrintAttributes, PrintShaderInfo } from './Z_Debug/GfxDebug.js';
import * as GlOps from './Buffers/GlBufferOps.js';
import { GlCreateShaderInfo, LoadShaderProgram } from './GlShaders.js';
import { GlUseProgram } from './Buffers/GlBuffers.js';
import { UniformsBuffer } from './Buffers/GlUniformBuffer.js';

// Global Gl Program object
let g_glPrograms = [];
let g_glProgramsCount = 0;


export function GlIncrProgramsCnt(){g_glProgramsCount++;}
export function GlGetProgramsCnt(){return g_glProgramsCount;}
export function GlGetPrograms(){ return g_glPrograms; }
export function GlGetProgram(progIdx){ return g_glPrograms[progIdx]; }
export function GlStoreProgram(progIdx, program){ g_glPrograms[progIdx] = program; }
export function GlGetVB(progIdx, vbIdx){ return g_glPrograms[progIdx].vertexBuffer[vbIdx]; }
export function GlGetIB(progIdx, ibIdx){ return g_glPrograms[progIdx].indexBuffer[ibIdx]; }



export class GfxInfoMesh {

	sceneIdx = INT_NULL;
	sid = INT_NULL;
	numFaces = 0;
	vertsPerRect = 0;
	attribsPerVertex = 0;
	meshIdx = INT_NULL; // The index of the current mesh in the vertexBuffer's array of meshes

	prog = {
		idx: INT_NULL,
	}
	vao = null;

	vb = { // The vertex buffer info the mesh belongs to

		buffer: null,
		idx: INT_NULL,			// The vertex buffer (float*) idx that this Mesh is stored to.
		start: 0,		// The current meshe's starting idx in vertex buffer. 
		count: 0,		// Current size of the float buffer (in floats)
	};

	ib = { // The vertex buffer info the mesh belongs to

		buffer: null,
		idx: INT_NULL,			// The idx buffer's  idx.
		start: 0,		// The current meshe's starting idx in vertex buffer. 
		count: 0,		// Number of total meshe's attributes  
	};

	tb = { // The Texture info for the mesh

		id: INT_NULL,     // An id generated by webGl (texture unit: GL_TEXTURE0)
		idx: INT_NULL,
	};
}



export class GlProgram extends Camera {

	program = null;
	isActive = false;

	uniformsNeedUpdate = false;

	info = {
		sid: 0,				// Shader Type ID (E.g. ATTR_COL4 | ATTR_POS2 | INDEXED)
		programId: 0,
		progIdx: INT_NULL,
	};
	shaderInfo = {
		colOffset: INT_NULL,
		posOffset: INT_NULL,
		scaleOffset: INT_NULL,
		texOffset: INT_NULL,
		wposTimeOffset: INT_NULL,
		styleOffset: INT_NULL,   // Radius for rounding corners
		timeOffset: INT_NULL,	// Border feather distance	
		sdfParamsOffset: INT_NULL,	// The inner and outer variables to render sdf text
		params1Offset: INT_NULL,	// The inner and outer variables to render sdf text

		attributes: {
			colLoc: INT_NULL,
			posLoc: INT_NULL,
			scaleLoc: INT_NULL,
			texLoc: INT_NULL,
			wposTimeLoc: INT_NULL,
			styleLoc: INT_NULL,
			timeLoc: INT_NULL,
			sdfParamsLoc: INT_NULL,
			params1Loc: INT_NULL,
		},

		uniforms: {
			orthoProj: null,
			sampler: null,
			uniformsBuffer: null,    // Uniform Buffer
			uniformsBufferLoc: null,    // Uniform Location
			positionsBuffer: null,    // Uniform Buffer
			positionsBufferLoc: null,    // Uniform Location
			uniformsBufferCount: 0,         // Counts the numbber of uniform values
		},

		attribsPerVertex: 0,
		verticesPerRect: 0,
	};
	timer = {
		t: 0., // A uniform variable to time counter
		step: 0.,
		index: INT_NULL,
		isOn: false,
	};

	vertexBuffer = [];
	vertexBufferCount = 0;

	indexBuffer = [];
	indexBufferCount = 0;

	SetTimer(step, uniformBufferIndex) {
		this.timer.isOn = true;
		this.timer.step = step;
		this.timer.index = uniformBufferIndex;
	}
	UpdateTimer() {
		this.shaderInfo.uniforms.uniformsBuffer[this.timer.index] = this.timer.t;
		this.uniformsNeedUpdate = true;
		// Increment program's uniform variable timer
		this.timer.t += this.timer.step;
	}

	/**
	 * Uniform buffer for miscellaneous-arbitary number of uniforms for a specific gl program 
	 */
	UniformsSetuniformsBufferValue(value, index) {
		this.shaderInfo.uniforms.uniformsBuffer[index] = value;
		this.uniformsNeedUpdate = true;
	}

	UniformsUpdateuniformsBuffer(gl) {
		gl.uniform1fv(this.shaderInfo.uniforms.uniformsBufferLoc, this.shaderInfo.uniforms.uniformsBuffer); // And the shader decides the number of elements to draw from the buffer
		this.uniformsNeedUpdate = false;
	}

};


/*
 * Generalized Program Web Gl Creation 
 */
export function GlCreateProgram(sid) {

	const prog = new GlProgram;
	const progIdx = GlGetProgramsCnt();
	GlIncrProgramsCnt();
	prog.info.progIdx = progIdx;
	prog.program = LoadShaderProgram(gfxCtx.gl, sid);

	GlUseProgram(prog.program, progIdx)
	prog.shaderInfo = GlCreateShaderInfo(gfxCtx.gl, prog.program, sid);
	PrintShaderInfo(prog);

	prog.info.sid = sid;
	GlStoreProgram(progIdx, prog);

	/** Set up static uniforms (static: exist for all programs) */
	// Initialize Camera
	prog.CameraSet();
	
	// Create uniforms buffer. TODO: Create a dynamic uniformsBuffer Float32Array, by knowing the num of uniforms all meshes will create.
	prog.shaderInfo.uniforms.uniformsBuffer = null;
	const uniformsBuffer = new UniformsBuffer(gfxCtx.gl, prog.program, 5);
	if(uniformsBuffer)
		prog.shaderInfo.uniforms.uniformsBuffer = new UniformsBuffer(gfxCtx.gl, prog.program, 5);

	/**
	 * Create an array of uniform values.
	 * UNIFORM_PARAMS.WHT = Width-Height-Time uniform parameters.
	 * The Width and Height of the App's screen resolution, 
	 * and a timer that can be different only between gl programs(prog.timer.t).
	 * For unique timers for any specific mesh, USE time attribute.  
	 * Some of the shaders use only 2 uniforms(Width and Height) and not the time.
	 * That's ok from efficiency point of view, as the uniform is bound only here(once)
	 */
	// if (
	//     sid & SID.FX.FS_EXPLOSION_CIRCLE ||
	//     sid & SID.FX.FS_EXPLOSION_SIMPLE ||
	//     sid & SID.FX.FS_VOLUMETRIC_EXPLOSION ||
	//     sid & SID.FX.FS_CRAMBLE ||
	//     sid & SID.FX.FS_VORONOI_EXPLOSION ||
	//     sid & SID.FX.FS_GRADIENT ||
	//     sid & SID.FX.FS_V2DGFX ||
	//     sid & SID.DEF2 || sid & SID.DEF3 ||
	//     sid & SID.FX.FS_GLOW ||
	//     sid & SID.FX.FS_SHADOW ||
	//     sid & SID.FX.FS_NOISE ||
	//     sid & SID.TEST_SHADER
	// ) {
	//     UNIFORM_PARAMS.WHT.progIdx = progIdx;
	//     // Create the uniforms buffer 
	//     prog.shaderInfo.uniforms.uniformsBuffer = new Float32Array(UNIFORM_PARAMS.WHT.count);
	//     prog.UniformsSetuniformsBufferValue(Viewport.width, UNIFORM_PARAMS.WHT.widthIdx);
	//     prog.UniformsSetuniformsBufferValue(Viewport.height, UNIFORM_PARAMS.WHT.heightIdx);
	//     prog.UniformsSetuniformsBufferValue(prog.timer.t, UNIFORM_PARAMS.WHT.timeIdx);
	// }
	// if (sid & SID.FX.FS_PARTICLES) {

	//     UNIFORM_PARAMS.particles.progIdx = progIdx;
	//     // Create the uniforms buffer 
	//     prog.shaderInfo.uniforms.uniformsBuffer = new Float32Array(UNIFORM_PARAMS.particles.count);
	//     prog.UniformsSetuniformsBufferValue(Viewport.width, UNIFORM_PARAMS.particles.widthIdx);
	//     prog.UniformsSetuniformsBufferValue(Viewport.height, UNIFORM_PARAMS.particles.heightIdx);
	//     prog.UniformsSetuniformsBufferValue(0, UNIFORM_PARAMS.particles.speedIdx);
	// }
	// if (sid & SID.FX.FS_VORTEX) {

	//     UNIFORM_PARAMS.particles.progIdx = progIdx;
	//     // Create the uniforms buffer 
	//     prog.shaderInfo.uniforms.uniformsBuffer = new Float32Array(UNIFORM_PARAMS.VORTEX.count);
	//     prog.UniformsSetuniformsBufferValue(Viewport.width, UNIFORM_PARAMS.VORTEX.widthIdx);
	//     prog.UniformsSetuniformsBufferValue(Viewport.height, UNIFORM_PARAMS.VORTEX.heightIdx);
	//     prog.UniformsSetuniformsBufferValue(0, UNIFORM_PARAMS.VORTEX.radiusIdx);
	// }

	// if (sid & SID.FX.FS_TWIST) {

	//     UNIFORM_PARAMS.WHT.progIdx = progIdx;
	//     // Create the uniforms buffer 
	//     prog.shaderInfo.uniforms.uniformsBuffer = new Float32Array(UNIFORM_PARAMS.TWIST.count);
	//     prog.UniformsSetuniformsBufferValue(Viewport.width, UNIFORM_PARAMS.TWIST.widthIdx);
	//     prog.UniformsSetuniformsBufferValue(Viewport.height, UNIFORM_PARAMS.TWIST.heightIdx);
	//     prog.UniformsSetuniformsBufferValue(Viewport.height, UNIFORM_PARAMS.TWIST.timeIdx);
	//     prog.UniformsSetuniformsBufferValue(Viewport.height, UNIFORM_PARAMS.TWIST.dirIdx);
	//     prog.SetTimer(0.1, UNIFORM_PARAMS.WHT.timeIdx);
	//     // Dir uniform is for the direction of the twist 
	//     prog.UniformsSetuniformsBufferValue(1., UNIFORM_PARAMS.WHT.dirIdx);
	// }
	
	PrintAttributes(gfxCtx.gl);

	return progIdx;
}





export let GlFrameBuffer = {

	name: '',

	buffer: null,
	tex: null,
	texId: INT_NULL,
	texIdx: INT_NULL,
	texWidth: 0,
	texHeight: 0,
	progIdx: INT_NULL,
	vbIdx: INT_NULL,
	isActive: false,
};

let GlUID = INT_NULL; // A unique id for every vertex buffer, to distinguish which meshes belong to which buffer 
export function GlCreateUniqueBufferid() {
	GlUID++;
	return GlUID;
}