"use strict";
import { CameraOrthographic, CameraPerspective } from '../Engine/Renderers/Renderer/Camera.js'
import { GetShaderTypeId, PrintAttributes, PrintShaderInfo } from './Z_Debug/GfxDebug.js';
import * as GlOps from './Buffers/GlBufferOps.js';
import { GlCreateShaderInfo, LoadShaderProgram } from './GlShaders.js';
import { GlUseProgram } from './Buffers/GlBuffers.js';
import { Uniform, UniformsBuffer } from './Buffers/GlUniformBuffer.js';
import { TimerGetGlobalTimer } from '../Engine/Timer/Timer.js';

// Global Gl Program object
let g_glPrograms = [];
let g_glProgramsCount = 0;


export function GlIncrProgramsCnt() { g_glProgramsCount++; }
export function GlGetProgramsCnt() { return g_glProgramsCount; }
export function GlGetPrograms() { return g_glPrograms; }
export function GlGetProgram(progIdx) { return g_glPrograms[progIdx]; }
export function GlStoreProgram(progIdx, program) { g_glPrograms[progIdx] = program; }
export function GlGetVB(progIdx, vbIdx) { return g_glPrograms[progIdx].vertexBuffer[vbIdx]; }
export function GlGetIB(progIdx, ibIdx) { return g_glPrograms[progIdx].indexBuffer[ibIdx]; }

export function GlGetProgramShaderInfo(progIdx) { return g_glPrograms[progIdx].shaderInfo; }
export function GlGetProgramUniformLocations(progIdx) { return g_glPrograms[progIdx].shaderInfo.uniforms; }



export class GfxInfoMesh {

	sceneIdx = INT_NULL;
	sid = INT_NULL;
	numFaces = 0;
	vertsPerRect = 0;
	attribsPerVertex = 0;
	meshIdx = INT_NULL; // The index of the current mesh in the vertexBuffer's array of meshes

	prog = {
		idx: INT_NULL,
	}
	vao = null;

	vb = { // The vertex buffer info the mesh belongs to

		buffer: null,
		idx: INT_NULL,			// The vertex buffer (float*) idx that this Mesh is stored to.
		start: 0,		// The current meshe's starting idx in vertex buffer. 
		count: 0,		// Current size of the float buffer (in floats)
	};

	ib = { // The vertex buffer info the mesh belongs to

		buffer: null,
		idx: INT_NULL,			// The idx buffer's  idx.
		start: 0,		// The current meshe's starting idx in vertex buffer. 
		count: 0,		// Number of total meshe's attributes  
	};

	tb = { // The Texture info for the mesh

		id: INT_NULL,     // An id generated by webGl (texture unit: GL_TEXTURE0)
		idx: INT_NULL,
	};
}



// export class GlProgram extends CameraOrthographic {
// export class GlProgram extends CameraPerspective {
export class GlProgram {

	constructor(gl, sid) {

		this.sid = sid; // Shader Type ID (E.g. ATTR_COL4 | ATTR_POS2 | INDEXED)
		this.idx = GlGetProgramsCnt();
		GlIncrProgramsCnt();

		this.webgl_program = null;
		this.isActive = false;

		this.uniformsNeedUpdate = false;

		this.vertexBuffer = [];
		this.vertexBufferCount = 0;

		this.indexBuffer = [];
		this.indexBufferCount = 0;

		this.webgl_program = LoadShaderProgram(gfxCtx.gl, sid);

		GlUseProgram(this.webgl_program, this.idx)
		PrintShaderInfo(this);

		this.shaderInfo = {

			attributes: {
				size: this.#PrivateCalculateAttributesSize(this.sid),
				loc: {
					col: gl.getAttribLocation(this.webgl_program, 'a_col'), // Color	
					wposTime: gl.getAttribLocation(this.webgl_program, 'a_wpos_time'), // World Position + Time attrib	 		
					pos: gl.getAttribLocation(this.webgl_program, 'a_pos'),	// Vertex Position	 
					tex: gl.getAttribLocation(this.webgl_program, 'a_tex'), // texture Coords	 		 		
					params1: gl.getAttribLocation(this.webgl_program, 'a_params1'), // A 4 component vector to pass any parameter to a vertex as an attribute 	 		
					sdf: gl.getAttribLocation(this.webgl_program, 'a_sdf'),	// For Sdf's  	 		 		
				},
				offset: {
					col: INT_NULL,
					wposTime: INT_NULL,
					pos: INT_NULL,
					tex: INT_NULL,
					params1: INT_NULL,
					sdf: INT_NULL,
				},
			},

			uniforms: {
				// Static uniforms
				// projection: gl.getUniformLocation(this.webgl_program, 'u_projection'), 	// Projection Matrix4 	
				projection: new Uniform(
					/* value */ 	0,
					/* Location */ gl.getUniformLocation(this.webgl_program, 'u_projection'),
					/* type */		UNIF_TYPES.MAT4,
				),
				sampler: gl.getUniformLocation(this.webgl_program, 'u_sampler0'),	// Sampler for texture units 	
				buffer: new UniformsBuffer(gfxCtx.gl, this, 5),
				// needsUpdate: false,
			},

			attribsPerVertex: 0,
			verticesPerRect: 0,
		};

		// Create uniforms buffer. TODO: Create a dynamic buffer Float32Array, by knowing the num of uniforms all meshes will create.
		// this.shaderInfo.uniforms.buffer = new UniformsBuffer(gfxCtx.gl, this, 5);

		this.timer = {
			val: 0., // A uniform variable to time counter
			step: 0.,
			index: INT_NULL,
			isActive: false,
		};

		GlStoreProgram(this.idx, this);
		console.log('-- GetShaderTypeId(): --\n', GetShaderTypeId(this.sid));
		// console.log('-- GetShaderTypeId(): --\n', this.shaderInfo.attributes.colLoc);

		this.#PrivateCreateAttribsOffsets();
	}

	#PrivateCalculateAttributesSize(sid) {
		return {
			col: (sid.attr & SID.ATTR.COL4) ? 4 : (0),
			wposTime: (sid.attr & SID.ATTR.WPOS_TIME4) ? 4 : (0),
			pos: (sid.attr & SID.ATTR.POS2) ? 2 : (0),
			tex: (sid.attr & SID.ATTR.TEX2) ? 2 : (0),
			params1: (sid.attr & SID.ATTR.PARAMS1) ? 4 : (0),
			time: (sid.attr & SID.ATTR.TIME) ? 1 : (0),
			sdf: (sid.attr & SID.ATTR.SDF_PARAMS) ? 2 : (0),
			style: (sid.attr & SID.ATTR.STYLE) ? 3 : (0),
		}
	}
	#PrivateCreateAttribsOffsets() {
		{
			// Sort the attributes by their location in the shader
			const obj = this.shaderInfo.attributes.loc;
			const sortedAttribLocations = Object.entries(obj)
				.sort(([, v1], [, v2]) => v1 - v2)
				.reduce((obj, [k, v]) => ({
					...obj,
					[k]: v
				}), {});

			// for (let prop in sortedAttribLocations) {
			// 	if (sortedAttribLocations[prop] > INT_NULL) {
			// 		console.log(prop, ':', sortedAttribLocations[prop])
			// 	}
			// }

			// Store back the sorted version
			this.shaderInfo.attributes.loc = sortedAttribLocations;


			/**
			 * Calculate attribute's offsets (it's byte offset in the vertex buffer)
			 * !IMPORTANT!: For any new attributes added in any vertex shader, include it as shown below 
			 */
			let attribsOffset = 0;
			for (let prop in sortedAttribLocations) {
				if (sortedAttribLocations[prop] > INT_NULL) {
					if (prop === 'col') {
						this.shaderInfo.attributes.offset.col = attribsOffset;
						attribsOffset += this.shaderInfo.attributes.size.col;
					}
					else if (prop === 'pos') {
						this.shaderInfo.attributes.offset.pos = attribsOffset;
						attribsOffset += this.shaderInfo.attributes.size.pos;
					}
					else if (prop === 'wposTime') {
						this.shaderInfo.attributes.offset.wposTime = attribsOffset;
						attribsOffset += this.shaderInfo.attributes.size.wposTime - 1;
						// HACK. TODO, correct
						this.shaderInfo.attributes.offset.time = attribsOffset;
						attribsOffset += 1;
					}
					else if (prop === 'tex') {
						this.shaderInfo.attributes.offset.tex = attribsOffset;
						attribsOffset += this.shaderInfo.attributes.size.tex;
					}
					else if (prop === 'params1') {
						this.shaderInfo.attributes.offset.params1 = attribsOffset;
						attribsOffset += this.shaderInfo.attributes.size.params1;
					}
					else if (prop === 'style') {
						this.shaderInfo.attributes.offset.style = attribsOffset;
						attribsOffset += this.shaderInfo.attributes.size.style;
					}
					else if (prop === 'sdf') {
						this.shaderInfo.attributes.offset.sdf = attribsOffset;
						attribsOffset += this.shaderInfo.attributes.size.sdf;
					}
				}
			}

			// Store the total attributes count
			this.shaderInfo.attribsPerVertex = attribsOffset;
			// Store the total vertices per rectangle mesh based on Indexed geometry or not
			if (this.sid.shad & SID.SHAD.INDEXED)
				this.shaderInfo.verticesPerRect = VERTS_PER_RECT_INDEXED;
			else
				this.shaderInfo.verticesPerRect = VERTS_PER_RECT;

			console.log('ShaderInfo:', this.shaderInfo)

		}
	}

	/**
	 * Uniforms Buffer
	 */
	UniformsCreateBufferUniform(name) {
		this.shaderInfo.uniforms.buffer.CreateUniform(name);
	}
	UniformsSetBufferUniform(val, index) {
		this.shaderInfo.uniforms.buffer.Set(val, index);
	}
	UniformsCreateSetBufferUniform(name, val) {
		const idx = this.shaderInfo.uniforms.buffer.CreateUniform(name);
		this.shaderInfo.uniforms.buffer.Set(val, idx);
	}
	UniformsUpdateBufferUniforms(gl) {
		if (this.shaderInfo.uniforms.buffer.needsUpdate) {
			this.shaderInfo.uniforms.buffer.Update(gl);
		}
	}
	UniformsSetUpdateBufferUniform(gl, val, index) {
		this.shaderInfo.uniforms.buffer.Set(val, index);
		this.shaderInfo.uniforms.buffer.Update(gl);
	}

	/**
	 * Unique Uniforms.
	 * New uniforms that are set by the client and are created as a seperate uniforms in the shaders.
	 */
	UniformsCreateTimer(step) {
		this.timer.isActive = true;
		this.timer.step = step;
		this.timer.index = this.shaderInfo.uniforms.buffer.CreateUniform('Timer');
	}
	UniformsUpdateTimer() {
		this.shaderInfo.uniforms.buffer.Set(this.timer.val, this.timer.index);
		this.uniformsNeedUpdate = true;
		this.timer.val += this.timer.step;
	}
	UniformsBufferCreateScreenRes() {
		const resXidx = this.shaderInfo.uniforms.buffer.CreateUniform('ScreenResX');
		const resYidx = this.shaderInfo.uniforms.buffer.CreateUniform('ScreenResY');
		// this.shaderInfo.uniforms.buffer.Set(Viewport.width, resXidx);
		// this.shaderInfo.uniforms.buffer.Set(Viewport.height, resYidx);
		return {
			resXidx:resXidx,
			resYidx:resYidx,
		};
	}
	// UniformsBufferUpdateScreenRes(xidx, yidx) {
	// 	this.shaderInfo.uniforms.buffer.Set(Viewport.width, xidx);
	// 	this.shaderInfo.uniforms.buffer.Set(Viewport.height, yidx);
	// }


	/**
	 * Static Uniforms
	 * Uniforms that are defined in every new program creation.
	 */
	UniformsSetProjectionMatrix(val) {
		this.shaderInfo.uniforms.projection.Set(val);
	}
	UniformsUpdateProjectionMatrix(gl) {
		this.shaderInfo.uniforms.projection.Update(gl);
	}
	UniformsSetUpdateProjectionMatrix(gl, val) {
		this.shaderInfo.uniforms.projection.Set(val);
		this.shaderInfo.uniforms.projection.Update(gl);
	}

	/**
	 * Update all uniforms of glProgram.
	 * Not neccesary cause it needs a lot of conditional statements
	 */
	UniformsUpdate(gl) {
		if (this.shaderInfo.uniforms.buffer.needsUpdate) {
			this.shaderInfo.uniforms.buffer.Update(gl);
		}
		if (this.shaderInfo.uniforms.projection.needsUpdate) {
			this.shaderInfo.uniforms.projection.Update(gl, val);
		}
		this.uniformsNeedUpdate = false;
	}


	/**
	 * Uniform buffer for miscellaneous-arbitary number of uniforms for a specific gl program 
	 */

	// CreateUniformsBufferUniform(value) {
	// 	this.uniformsNeedUpdate = true;
	// 	return this.shaderInfo.uniforms.buffer.Create(value);
	// }
	// UniformsSetBufferUniform(value, index) {
	// 	this.shaderInfo.uniforms.buffer.Set(value, index);
	// 	this.uniformsNeedUpdate = true;
	// }

	// UniformsUpdateUniformsBuffer(gl) {
	// 	gl.uniform1fv(this.shaderInfo.uniforms.uniformsBufferLoc, this.shaderInfo.uniforms.buffer); // And the shader decides the number of elements to draw from the buffer
	// 	this.uniformsNeedUpdate = false;
	// }

};


/*
 * Generalized Program Web Gl Creation 
 */
export function GlCreateProgram(sid) {
	const prog = new GlProgram(gfxCtx.gl, sid);
	return prog.idx;
}


/**
 * Enabling Attribute locations for a program
 * and
 * Setting the attribute's offsets, types and sizes. 
 * Cannot be implemented in GlProgram class because it needs vao-vbo binding first.
 * 
 * @param {*} gl : Gl context
 * @param {*} prog : The program to which we set enable the attribute locations
 */
export function GlEnableAttribsLocations(gl, prog) {

	const attribsPerVertex = prog.shaderInfo.attribsPerVertex;
	// For Uniforms
	if (prog.shaderInfo.attributes.loc.col >= 0) {
		gl.enableVertexAttribArray(prog.shaderInfo.attributes.loc.col);
		gl.vertexAttribPointer(prog.shaderInfo.attributes.loc.col,
			V_COL_COUNT, gl.FLOAT, false, attribsPerVertex * FLOAT, prog.shaderInfo.attributes.offset.col * FLOAT);
	}
	if (prog.shaderInfo.attributes.loc.pos >= 0) {
		gl.enableVertexAttribArray(prog.shaderInfo.attributes.loc.pos);
		gl.vertexAttribPointer(prog.shaderInfo.attributes.loc.pos,
			V_POS_COUNT, gl.FLOAT, false, attribsPerVertex * FLOAT, prog.shaderInfo.attributes.offset.pos * FLOAT);
	}
	if (prog.shaderInfo.attributes.loc.tex >= 0) {
		gl.enableVertexAttribArray(prog.shaderInfo.attributes.loc.tex);
		gl.vertexAttribPointer(prog.shaderInfo.attributes.loc.tex,
			V_TEX_COUNT, gl.FLOAT, false, attribsPerVertex * FLOAT, prog.shaderInfo.attributes.offset.tex * FLOAT);
	}
	if (prog.shaderInfo.attributes.loc.wposTime >= 0) {
		gl.enableVertexAttribArray(prog.shaderInfo.attributes.loc.wposTime);
		gl.vertexAttribPointer(prog.shaderInfo.attributes.loc.wposTime,
			V_WPOS_TIME_COUNT, gl.FLOAT, false, attribsPerVertex * FLOAT, prog.shaderInfo.attributes.offset.wposTime * FLOAT);
	}
	if (prog.shaderInfo.attributes.loc.params1 >= 0) {
		gl.enableVertexAttribArray(prog.shaderInfo.attributes.loc.params1);
		gl.vertexAttribPointer(prog.shaderInfo.attributes.loc.params1,
			V_PARAMS1_COUNT, gl.FLOAT, false, attribsPerVertex * FLOAT, prog.shaderInfo.attributes.offset.params1 * FLOAT);
	}
	if (prog.shaderInfo.attributes.loc.style >= 0) {
		gl.enableVertexAttribArray(prog.shaderInfo.attributes.loc.style);
		gl.vertexAttribPointer(prog.shaderInfo.attributes.loc.style,
			V_STYLE_COUNT, gl.FLOAT, false, attribsPerVertex * FLOAT, prog.shaderInfo.attributes.offset.style * FLOAT);
	}
	if (prog.shaderInfo.attributes.loc.time >= 0) {
		gl.enableVertexAttribArray(prog.shaderInfo.attributes.loc.time);
		gl.vertexAttribPointer(prog.shaderInfo.attributes.loc.time,
			V_TIME_COUNT, gl.FLOAT, false, attribsPerVertex * FLOAT, prog.shaderInfo.attributes.offset.time * FLOAT);
	}
	if (prog.shaderInfo.attributes.loc.sdf >= 0) {
		gl.enableVertexAttribArray(prog.shaderInfo.attributes.sdfLoc);
		gl.vertexAttribPointer(prog.shaderInfo.attributes.sdfLoc,
			V_SDF_PARAMS_COUNT, gl.FLOAT, false, attribsPerVertex * FLOAT, prog.shaderInfo.attributes.offset.sdf * FLOAT);
	}
}


export function GlProgramUpdateUniformProjectionMatrix(gl, mat4){
	const progs = g_glPrograms;
	const count = g_glProgramsCount;
	for(let i=0; i<count; i++){
		if(progs[i].shaderInfo.uniforms.projection){
			progs[i].UniformsSetUpdateProjectionMatrix(gl, mat4);
		}
	}
}


let GlUID = INT_NULL; // A unique id for every vertex buffer, to distinguish which meshes belong to which buffer 
export function GlCreateUniqueBufferid() {
	GlUID++;
	return GlUID;
}