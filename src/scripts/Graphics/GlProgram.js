"use strict";
import { PrintShaderInfo } from './Z_Debug/GfxDebug.js';
import { LoadShaderProgram } from './GlShaders.js';
import { GlUseProgram } from './Buffers/GlBuffers.js';
import { Uniform, UniformsBuffer } from './Buffers/GlUniformBuffer.js';
import { SHADER_CONSTANTS } from './Shaders/ConstructShader.js';
import { Renderqueue_set_active } from '../Engine/Renderers/Renderer/RenderQueue.js';



export class GfxInfoMesh {

	sid = INT_NULL;
	sceneidx = INT_NULL;
	scene_gfx_mesh_idx = INT_NULL; // The index of the mesh inside the scenes gfx buffer.
	isPrivate = false;
	numFaces = 0;
	vertsPerRect = 0;
	attribsPerVertex = 0;
	meshIdx = INT_NULL; // The index of the current mesh from scene's mesh buffer.
	vao = null;
	progs_groupidx = INT_NULL; // TODO: Decide if this var should be a bool or a bi-field.
	
	gfx_ctx = { // This refers to the GfxCtx2 class interface. GfxCtx2 is used to connect Engine system with application's Graphic System. 
		sessionId: INT_NULL, // If the vertex buffer has private use, the sessionid 'categorizes' all the vertex buffers belonging to a session. 
		idx: INT_NULL // The index of the GfxCtx buffer. 
	}

	prog = {
		idx: INT_NULL,
	}

	vb = { // The vertex buffer info the mesh belongs to
		idx: INT_NULL,	// The vertex buffer (float*) idx that this Mesh is stored to.
		start: 0,		// The current meshe's starting idx in vertex buffer. 
		count: 0,		// Current size of the float buffer (in floats)
	};

	ib = { // The vertex buffer info the mesh belongs to
		idx: INT_NULL,	// The idx buffer's  idx.
		start: 0,		// The current meshe's starting idx in vertex buffer. 
		count: 0,		// Number of total meshe's attributes  
		vertices_per_rect: 0,
	};

	tb = { // The Texture info for the mesh
		id: INT_NULL,  // An id generated by webGl (texture unit: GL_TEXTURE0)
		idx: INT_NULL,
	};

	constructor(gfxInfoMesh = {}) {

		if (gfxInfoMesh instanceof GfxInfoMesh) {

			this.sid = gfxInfoMesh.sid;
			this.sceneidx = gfxInfoMesh.sceneidx;
			this.numFaces = gfxInfoMesh.numFaces;
			this.vertsPerRect = gfxInfoMesh.vertsPerRect;
			this.attribsPerVertex = gfxInfoMesh.attribsPerVertex;
			this.meshIdx = gfxInfoMesh.meshIdx; 
			this.progs_groupidx = gfxInfoMesh.progs_groupidx;
			this.vao = gfxInfoMesh.vao; 
			
			this.prog.idx = gfxInfoMesh.prog.idx; 
		
			this.vb.idx = gfxInfoMesh.vb.idx;
			this.vb.start = gfxInfoMesh.vb.start;
			this.vb.count = gfxInfoMesh.vb.count;

			this.ib.idx = gfxInfoMesh.ib.idx;
			this.ib.start = gfxInfoMesh.ib.start;
			this.ib.count = gfxInfoMesh.ib.count;

			this.tb.id = gfxInfoMesh.tb.id;
			this.tb.idx = gfxInfoMesh.tb.idx;
		}
	}

	Copy(gfx = {}){

		if (gfx instanceof GfxInfoMesh) {

			this.sid.Copy(gfx.sid);
			this.sceneidx = gfx.sceneidx;
			this.numFaces = gfx.numFaces;
			this.vertsPerRect = gfx.vertsPerRect;
			this.attribsPerVertex = gfx.attribsPerVertex;
			this.meshIdx = gfx.meshIdx; 
			this.progs_groupidx = gfx.progs_groupidx;
			this.vao = gfx.vao; 
			
			this.prog.idx = gfx.prog.idx; 
		
			this.vb.idx = gfx.vb.idx;
			this.vb.start = gfx.vb.start;
			this.vb.count = gfx.vb.count;

			this.ib.idx = gfx.ib.idx;
			this.ib.start = gfx.ib.start;
			this.ib.count = gfx.ib.count;

			this.tb.id = gfx.tb.id;
			this.tb.idx = gfx.tb.idx;
		}
	}

}


class Gl_Programs {
	constructor(){
		this.buffer = []; // Buffer for gl shader programs
		this.count = 0;
	}

	CreateProgram(gl, sid){
		const progidx = this.count++;
		this.buffer[progidx] = new Gl_Program(gl, sid);
		return progidx;
	}
}

export class Gl_Program {

	constructor(gl, sid) {

		this.sid = sid; // Shader Type ID (E.g. ATTR_COL4 | ATTR_POS2 | INDEXED)

		this.webgl_program = null;
		this.isActive = false;

		this.uniformsNeedUpdate = false;

		this.vertexBuffer = [];
		this.vertexBufferCount = 0;

		this.indexBuffer = [];
		this.indexBufferCount = 0;

		this.webgl_program = LoadShaderProgram(gfxCtx.gl, sid);

		PrintShaderInfo(this);

		this.shaderinfo = {

			attributes: {
				
				size: this.#PrivateCalculateAttributesSize(this.sid),
				
				loc: {

					col: gl.getAttribLocation(this.webgl_program, 'a_col'), // Color	
					wposTime: gl.getAttribLocation(this.webgl_program, 'a_wpos_time'), // World Position + Time attrib	 		
					pos: gl.getAttribLocation(this.webgl_program, 'a_pos'),	// Vertex Position	 
					tex: gl.getAttribLocation(this.webgl_program, 'a_tex'), // texture Coords	 		 		
					params1: gl.getAttribLocation(this.webgl_program, 'a_params1'), // A 4 component vector to pass any parameter to a vertex as an attribute 	 		
					sdf: gl.getAttribLocation(this.webgl_program, 'a_sdf'),	// For Sdf's  	 		 		
				},

				offset: {

					col: INT_NULL,
					wposTime: INT_NULL,
					pos: INT_NULL,
					tex: INT_NULL,
					params1: INT_NULL,
					sdf: INT_NULL,
				},
			},

			// Create uniforms buffer. TODO: Create a dynamic buffer Float32Array, by knowing the num of uniforms meshes will create.
			uniforms: {

				// Static uniforms
				projection: new Uniform(

					/* value */ 	0,
					/* Location */ gl.getUniformLocation(this.webgl_program, 'u_projection'),
					/* type */		UNIF_TYPE.MAT4,
				),
				sampler: gl.getUniformLocation(this.webgl_program, 'u_sampler0'),	// Sampler for texture units 	

				// Uniforms buffer. Stores any uniform as an array of values.
				buffer: new UniformsBuffer(gfxCtx.gl, this, SHADER_CONSTANTS.UNIFORM_BUFFER_COUNT),
			},

			attribsPerVertex: 0,
			verticesPerRect: 0,
		};


		this.timer = {
			val: 0., // A uniform variable to time counter
			step: 0.,
			index: INT_NULL,
			isActive: false,
		};

		this.#PrivateCreateAttribsOffsets();
	}

	// Check id sid matches with the program's sid.
	CheckSidMatch(sid){
		return SID.CheckSidMatch(sid, this.sid);
	}

	#PrivateCalculateAttributesSize(sid) {
		return {
			col: (sid.attr & SID.ATTR.COL4) ? 4 : (0),
			wpos: (sid.attr & SID.ATTR.WPOS_TIME4) ? 3 : (0),
			wposTime: (sid.attr & SID.ATTR.WPOS_TIME4) ? 4 : (0),
			pos: (sid.attr & SID.ATTR.POS2) ? 2 : (sid.attr & SID.ATTR.POS3) ? 3 : (0),
			tex: (sid.attr & SID.ATTR.TEX2) ? 2 : (0),
			params1: (sid.attr & SID.ATTR.PARAMS1) ? 4 : (0),
			time: ((sid.attr & SID.ATTR.TIME) || (sid.attr & SID.ATTR.WPOS_TIME4)) ? 1 : (0),
			sdf: (sid.attr & SID.ATTR.SDF) ? 2 : (0),
		}
	}
	#PrivateCreateAttribsOffsets() {
		{
			// Sort the attributes by their location in the shader
			const obj = this.shaderinfo.attributes.loc;
			const sortedAttribLocations = Object.entries(obj)
				.sort(([, v1], [, v2]) => v1 - v2)
				.reduce((obj, [k, v]) => ({
					...obj,
					[k]: v
				}), {});

			// if(DEBUG.SHADER_INFO){
			// 	for (let prop in sortedAttribLocations) {
			// 		if (sortedAttribLocations[prop] > INT_NULL) {
			// 			console.log(prop, ':', sortedAttribLocations[prop])
			// 		}
			// 	}
			// }

			// Store back the sorted version
			this.shaderinfo.attributes.loc = sortedAttribLocations;


			/**
			 * Calculate attribute's offsets (it's byte offset in the vertex buffer)
			 * !IMPORTANT!: For any new attributes added in any vertex shader, include it as shown below 
			 */
			let attribsOffset = 0;
			for (let prop in sortedAttribLocations) {

				if (sortedAttribLocations[prop] > INT_NULL) {

					if (prop === 'col') {
						this.shaderinfo.attributes.offset.col = attribsOffset;
						attribsOffset += this.shaderinfo.attributes.size.col;
					}
					else if (prop === 'pos') {
						this.shaderinfo.attributes.offset.pos = attribsOffset;
						attribsOffset += this.shaderinfo.attributes.size.pos;
					}
					else if (prop === 'wposTime') {
						this.shaderinfo.attributes.offset.wposTime = attribsOffset;
						attribsOffset += this.shaderinfo.attributes.size.wposTime - 1;
						// HACK. TODO, correct
						this.shaderinfo.attributes.offset.time = attribsOffset;
						attribsOffset += 1;
					}
					else if (prop === 'tex') {
						this.shaderinfo.attributes.offset.tex = attribsOffset;
						attribsOffset += this.shaderinfo.attributes.size.tex;
					}
					else if (prop === 'params1') {
						this.shaderinfo.attributes.offset.params1 = attribsOffset;
						attribsOffset += this.shaderinfo.attributes.size.params1;
					}
					// else if (prop === 'style') {
					// 	this.shaderinfo.attributes.offset.style = attribsOffset;
					// 	attribsOffset += this.shaderinfo.attributes.size.style;
					// }
					else if (prop === 'sdf') {
						this.shaderinfo.attributes.offset.sdf = attribsOffset;
						attribsOffset += this.shaderinfo.attributes.size.sdf;
					}
				}
			}

			// Store the total attributes count
			this.shaderinfo.attribsPerVertex = attribsOffset;
			// Store the total vertices per rectangle mesh based on Indexed geometry or not
			if (this.sid.shad & SID.SHAD.INDEXED)
				this.shaderinfo.verticesPerRect = VERTS_PER_RECT_INDEXED;
			else
				this.shaderinfo.verticesPerRect = VERTS_PER_RECT;

				if(DEBUG.SHADER_INFO) console.log('ShaderInfo:', this.shaderinfo)

		}
	}

	/** Update all program's Uniforms */
	UpdateUniforms(gl){

		if (this.timer.isActive) this,UniformsUpdateTimer();
		if (this.shaderinfo.uniforms.buffer.needsUpdate) {
			this.UniformsUpdateBufferUniforms(gl);
		}
	}

	/**
	 * Uniforms Buffer
	 */
	UniformsCreateBufferUniform(name) {
		this.shaderinfo.uniforms.buffer.CreateUniform(name);
	}

	UniformsSetBufferUniform(val, index) {
		this.shaderinfo.uniforms.buffer.Set(val, index);
	}

	UniformsCreateSetBufferUniform(name, val) {
		const idx = this.shaderinfo.uniforms.buffer.CreateUniform(name);
		this.shaderinfo.uniforms.buffer.Set(val, idx);
	}

	UniformsUpdateBufferUniforms(gl) {
			this.shaderinfo.uniforms.buffer.Update(gl);
	}

	UniformsSetUpdateBufferUniform(gl, val, index) {
		this.shaderinfo.uniforms.buffer.Set(val, index);
		this.shaderinfo.uniforms.buffer.Update(gl);
	}

	/**
	 * Unique Uniforms.
	 * New uniforms that are set by the client and are created as a seperate uniforms in the shaders.
	 */
	UniformsCreateTimer(step) {

		// 'Activates' 1 array element of the uniforms buffer array.
		this.timer.isActive = true;
		this.timer.step = step;
		this.timer.index = this.shaderinfo.uniforms.buffer.CreateUniform('Timer');
	}

	UniformsUpdateTimer() {

		this.shaderinfo.uniforms.buffer.Set(this.timer.val, this.timer.index);
		this.uniformsNeedUpdate = true;
		this.timer.val += this.timer.step;
	}

	UniformsBufferCreateScreenRes() {
		/**
		 * 'Activates' 2 array elements of the uniforms buffer array, and returns the 2 indexes
		 *  so the caller can 'Set' the uniforms value at it's site.
		 */
		const resXidx = this.shaderinfo.uniforms.buffer.CreateUniform('ScreenResX');
		const resYidx = this.shaderinfo.uniforms.buffer.CreateUniform('ScreenResY');

		return {
			resXidx: resXidx,
			resYidx: resYidx,
		};
	}

	/**
	 * Static Uniforms
	 * Uniforms that are used in every new program.
	 */
	UniformsSetProjectionMatrix(val) {
		this.shaderinfo.uniforms.projection.Set(val);
	}

	UniformsUpdateProjectionMatrix(gl) {
		this.shaderinfo.uniforms.projection.Update(gl);
	}

	UniformsSetUpdateProjectionMatrix(gl, val) {
		this.shaderinfo.uniforms.projection.Set(val);
		this.shaderinfo.uniforms.projection.Update(gl);
	}

	/**
	 * Update all uniforms of glProgram.
	 * Not neccesary cause it needs a lot of conditional statements
	 */
	UniformsUpdate(gl) {
		if (this.shaderinfo.uniforms.buffer.needsUpdate) {
			this.shaderinfo.uniforms.buffer.Update(gl);
		}
		if (this.shaderinfo.uniforms.projection.needsUpdate) {
			this.shaderinfo.uniforms.projection.Update(gl, val);
		}
		this.uniformsNeedUpdate = false;
	}

};

// Scoped global Gl Program object
// const _glPrograms = new Gl_Programs();
const _gl_programs_groups = {

	buffer: [],
	count: 0,

	CreateGroup(){
		const groupidx = this.count++;
		this.buffer[groupidx] = new Gl_Programs(); // Create new buffer to store gl shader programs
		return groupidx; // Return the index of the newly created group buffer.
	},

	CreateProgram(gl, sid){

		let program_group_idx = INT_NULL;
		if(!this.GroupExists(PROGRAMS_GROUPS.GetIdxByMask(sid.progs_group))){ // If group does not exist, create it.
			
			program_group_idx = this.CreateGroup();

			// Important! Here we set globaly the index of the program group.
			if(sid.progs_group & PROGRAMS_GROUPS.DEBUG.MASK) PROGRAMS_GROUPS.DEBUG.IDX = program_group_idx;
			else if(sid.progs_group & PROGRAMS_GROUPS.DEFAULT.MASK) PROGRAMS_GROUPS.DEFAULT.IDX = program_group_idx;
		}
		else program_group_idx = PROGRAMS_GROUPS.GetIdxByMask(sid.progs_group);

		const progidx = this.buffer[program_group_idx].CreateProgram(gl, sid); // Create the shader program
		console.log('++++ Program shader group:' , PROGRAMS_GROUPS.GetName(sid.progs_group), ' idx:', program_group_idx, ' progidx:', progidx)

		return {progidx:progidx, progs_groupidx:program_group_idx};
	},

	GroupExists(prog_group_idx){

		if(prog_group_idx !== INT_NULL && this.buffer[prog_group_idx]) return true;
		return false;
	},

};

export function Gl_progs_get() { 
	return _gl_programs_groups; 
}
export function Gl_progs_get_group(programs_groupidx=INT_NULL) { 
	return _gl_programs_groups.buffer[programs_groupidx]; 
}
export function Gl_progs_get_prog_byidx(programs_groupidx=INT_NULL, progIdx) { 
	return _gl_programs_groups.buffer[programs_groupidx].buffer[progIdx]; 
}
export function Gl_progs_get_vb_byidx(programs_groupidx=INT_NULL, progIdx, vbIdx) { 
	if(_gl_programs_groups.buffer[programs_groupidx] === undefined)
	console.log
	return _gl_programs_groups.buffer[programs_groupidx].buffer[progIdx].vertexBuffer[vbIdx]; 
}
export function Gl_progs_get_ib_byidx(programs_groupidx=INT_NULL, progIdx, ibIdx) { 
	return _gl_programs_groups.buffer[programs_groupidx].buffer[progIdx].indexBuffer[ibIdx]; 
}
export function Gl_progs_get_shaderinfo(programs_groupidx=INT_NULL, progIdx) { 
	return _gl_programs_groups.buffer[programs_groupidx].buffer[progIdx].shaderinfo; 
}
export function Gl_progs_get_shaderinfo_uniforms(programs_groupidx=INT_NULL, progIdx) { 
	return _gl_programs_groups.buffer[programs_groupidx].buffer[progIdx].shaderinfo.uniforms; 
}
export function Gl_progs_set_vb_texidx(programs_groupidx=INT_NULL, progIdx, vbIdx, textidx){ 
	_gl_programs_groups.buffer[programs_groupidx].buffer[progIdx].vertexBuffer[vbIdx].textidx = textidx; 
}


export function Gl_create_program(sid) {
	return _gl_programs_groups.CreateProgram(gfxCtx.gl, sid);
}
export function Gl_progs_get_programs_count(programs_groupidx=INT_NULL) { 
	return _gl_programs_groups.buffer[programs_groupidx].count;  
}

export function Gl_get_progams_count(programs_groupidx=INT_NULL) { 
	return _gl_programs_groups.buffer[programs_groupidx].count; 
}

export function Gl_set_vb_show(progIdx, vbIdx, programs_groupidx=INT_NULL, flag) {

	_gl_programs_groups.buffer[programs_groupidx].buffer[progIdx].vertexBuffer[vbIdx].show = flag;
	_gl_programs_groups.buffer[programs_groupidx].buffer[progIdx].indexBuffer[vbIdx].show = flag;
	Renderqueue_set_active(programs_groupidx, progIdx, vbIdx, flag); // Update the draw buffer
}

/**
 * Enabling Attribute locations for a program
 * and
 * Setting the attribute's offsets, types and sizes. 
 * Cannot be implemented in Gl_Program class because it needs vao-vbo binding first.
 * 
 * @param {*} gl : Gl context
 * @param {*} prog : The program to which we set enable the attribute locations
 */
export function GlEnableAttribsLocations(gl, prog) {

	const attribsPerVertex = prog.shaderinfo.attribsPerVertex;
	const loc = prog.shaderinfo.attributes.loc;
	const size = prog.shaderinfo.attributes.size;
	const offset = prog.shaderinfo.attributes.offset;


	// For Uniforms
	if (loc.col >= 0) {
		gl.enableVertexAttribArray(loc.col);
		gl.vertexAttribPointer(loc.col, size.col, gl.FLOAT, false, attribsPerVertex * FLOAT, offset.col * FLOAT);
	}
	if (loc.pos >= 0) {
		gl.enableVertexAttribArray(loc.pos);
		gl.vertexAttribPointer(loc.pos, size.pos, gl.FLOAT, false, attribsPerVertex * FLOAT, offset.pos * FLOAT);
	}
	if (loc.tex >= 0) {
		gl.enableVertexAttribArray(loc.tex);
		gl.vertexAttribPointer(loc.tex, size.tex, gl.FLOAT, false, attribsPerVertex * FLOAT, offset.tex * FLOAT);
	}
	if (loc.wposTime >= 0) {
		gl.enableVertexAttribArray(loc.wposTime);
		gl.vertexAttribPointer(loc.wposTime, size.wposTime, gl.FLOAT, false, attribsPerVertex * FLOAT, offset.wposTime * FLOAT);
	}
	if (loc.params1 >= 0) {
		gl.enableVertexAttribArray(loc.params1);
		gl.vertexAttribPointer(loc.params1, size.params1, gl.FLOAT, false, attribsPerVertex * FLOAT, offset.params1 * FLOAT);
	}
	if (loc.style >= 0) {
		gl.enableVertexAttribArray(loc.style);
		gl.vertexAttribPointer(loc.style, size.style, gl.FLOAT, false, attribsPerVertex * FLOAT, offset.style * FLOAT);
	}
	if (loc.time >= 0) {
		gl.enableVertexAttribArray(loc.time);
		gl.vertexAttribPointer(loc.time, size.time, gl.FLOAT, false, attribsPerVertex * FLOAT, offset.time * FLOAT);
	}
	if (loc.sdf >= 0) {
		gl.enableVertexAttribArray(loc.sdf);
		gl.vertexAttribPointer(loc.sdf, size.sdf, gl.FLOAT, false, attribsPerVertex * FLOAT, offset.sdf * FLOAT);
	}
}

export function GlProgramUpdateUniformProjectionMatrix(gl, progIdx, mat4, programs_groupidx=INT_NULL) {

	const prog = _gl_programs_groups.buffer[programs_groupidx].buffer[progIdx];
	GlUseProgram(prog.webgl_program); 
	prog.UniformsSetUpdateProjectionMatrix(gl, mat4);

}

export function GlCheckSid(sid, progidx){

	const progs_groupidx = PROGRAMS_GROUPS.GetIdxByMask(sid.progs_group);
	if(progs_groupidx === INT_NULL) return false; // Case  programs group hasn't been created
	
	const progs_group = Gl_progs_get_group(progs_groupidx);
	if(!progs_group.buffer[progidx]) return false;	// Case  program in programs group hasn't been created
	
	const prog = progs_group.buffer[progidx];
	
	if (SID.CheckSidMatch(sid, prog.sid)) return true;
	return false;
}

