#version 300 es
// Vertex Shader
precision mediump float;
//
#define UNIFORM_BUFFER_COUNT 5
//
in vec4 a_col;
in vec4 a_wpos_time;
in vec2 a_pos;
in vec4 a_params1;
//
uniform mat4 u_projection;
uniform float uniforms_buffer[UNIFORM_BUFFER_COUNT];
//
out float v_uniforms_buffer[UNIFORM_BUFFER_COUNT];
out vec4 v_col; 
out vec2 v_dim;
out vec2 v_wpos;
out float v_border_width;
out float v_rCorners;
out float v_border_feather;
//
void main(void) 
{
  gl_Position = u_projection * vec4(a_pos.x + a_wpos_time.x, a_pos.y + a_wpos_time.y, a_wpos_time.z, 1.0);
  v_col = a_col;
  v_dim = abs(a_pos);
  v_wpos = a_wpos_time.xy;
  v_border_width = a_params1.x;
  v_rCorners = a_params1.y;
  v_border_feather = a_params1.z;
  v_uniforms_buffer = uniforms_buffer;
} ConstructShader.js:123:30


#version 300 es
// Fragment Shader
//
#define UNIFORM_BUFFER_COUNT 5
#define UB_HAS_RESOLUTION
#define UB_IDX0 0
#define UB_IDX1 1
precision mediump float;
out vec4 frag_color;
//
in float v_uniforms_buffer[5];
in vec4 v_col;
in vec2 v_dim;
in vec2 v_wpos;
in float v_border_width;
in float v_rCorners;
in float v_border_feather;
//
vec4 pos = vec4(.0, .0, .0, .0); 
float ScreenH; 
float AA;   
vec2 length2(vec4 a) {  
    return vec2(length(a.xy), length(a.zw)); 
}  
vec2 RoundedRectangle(vec2 dim, float r, float bw) {              
  dim -= bw +.0002; // Subtract the border                        
  r = min(r, min(dim.x, dim.y));                                  
  dim -= r; // Subtract the border-radius                         
  vec4 d = abs(pos) - dim.xyxy;                                   
  vec4 dmin = min(d, 0.0);                                        
  vec4 dmax = max(d, 0.0);                                        
  vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);                
  return (df - r);                                                
}                                                                 
vec4 Stylize()                                                    
{                                                                 
  float t = v_uniforms_buffer[2];                                 
  // Radius(From 0.01 to 0.35 good values) for rounding corners   
  float rCorners = v_rCorners * .008;                             
  float feather = v_border_feather;                               
  
#ifdef UB_HAS_RESOLUTION
  vec2 res = vec2(v_uniforms_buffer[UB_IDX0], v_uniforms_buffer[UB_IDX1]);    
  res.x /= res.x/res.y;                                           
#else 
vec2 res = vec2(824., 893.);    
  res.x /= res.x/res.y;                                           
  return vec4(1.); 
#endif 
  vec2 uv = gl_FragCoord.xy/res;                                  
  uv -= vec2(v_wpos.x/res.x, 1.-(v_wpos.y/res.y));                
  pos.xy = uv;                                                    
  vec2 dim = vec2(v_dim.x/res.x, v_dim.y/res.y);                  
  // dim -= vec2(v_wpos.x/res.x, 1.-(v_wpos.y/res.y));                
  // vec2 dim = vec2(v_dim.x, v_dim.y);                  
  
  // From 0.3 to 1.2 good values                                  
  float clarity = 10.4;                                           
  // float clarity = 1.; // From 0.3 to 1.2 good values           
  ScreenH = min(res.x, res.y)*clarity;                            
  AA = ScreenH*.5;                                                
  
  vec2 blur = vec2(0.0, feather * .001);                          
  
  vec2 d = RoundedRectangle(dim, mix(0.0, .2, rCorners), 0.);     
  
  vec4 src = v_col;                                               
  vec3 color = vec3(0.0);                                         
  
  // Calculate alpha (for rounding corners)                       
  float dd = d.x - blur.x;                                        
  // float dd = min(d.x - blur.x, d.x-rCorners);                   
  // float wa = clamp(-dd * AA, 0.0, 1.);                         
  float wa = 1.;                                                  
  float wb = clamp(-dd / (blur.x+blur.y), 0.0, 1.);                
  float alpha = src.a * (wa * wb);                                
  color += color * (1.0 - alpha) + src.rgb * alpha;               
  
  // BORDER                                                       
  // Border Width. It is 0.001 for every pixel                    
  float borderWidth = v_border_width * 0.001;                      
  float bd = (abs(d.x)-borderWidth) - blur.x;                     
  wa = clamp(-bd * AA, 0.0, 1.0);                                 
  wb = clamp(-bd / (blur.x+blur.y), 0.0, 1.0);                    
  color += color * vec3(abs(wa * wb));              
  // color += vec3(.1,.4,.8) * vec3(abs(wa * wb));              
  // color *= 2.*vec3(abs(wa * wb));              
  
  // Bevel. // TODO: Control @colorIntensity for the pow() and @darkness for the mult of the pow() 
  // float r = min(rCorners*.17, min(dim.x, dim.y)); 
  // // float r = min(.023, min(dim.x, dim.y)); 
  // float f = smoothstep(r, .0, abs(d.x)-borderWidth); 
  // color = mix(color, pow(color, vec3(1.5))*.85, f); 
  
  // if(v_uniforms_buffer[2] > 10.) return vec4(1.); 
  return vec4(color, alpha); 
                      // // Calculate Gradient                                        
  // float dist = length(vec2(d.x, 0.1));                         
  // vec2 p0 = vec2(-dist, 0.0);                                  
  // vec2 p1 = vec2(dist, 0.0);                                   
  // vec2 pa = pos.xy - p0;                                       
  // vec2 ba = p1 - p0;                                           
} 

void main(void) 
{
  vec4 color = v_col;
  color = Stylize();
  frag_color = color;
  frag_color.xyz *= color.a;
}